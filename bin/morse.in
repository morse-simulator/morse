#! @PYTHON3_EXECUTABLE@
import sys
import os
import logging
import optparse
import argparse
## Configuring default logging
from morse.core.ansistrm import ColorizingStreamHandler
logger = logging.getLogger('morse')

log_handler = ColorizingStreamHandler()
formatter = logging.Formatter("* %(message)s\n")
log_handler.setFormatter(formatter)

logger.addHandler(log_handler)
logger.setLevel(logging.DEBUG)
##

import subprocess
import shutil
import glob
import re

VERSION = "@PACKAGE_VERSION@"

#Python version must be egal or bigger than...
MIN_PYTHON_VERSION = "3.0"
#Python version must be smaller than...
STRICT_MAX_PYTHON_VERSION = "4.0"

#Blender version must be egal or bigger than...
MIN_BLENDER_VERSION = "2.54"
#Blender version must be smaller than...
STRICT_MAX_BLENDER_VERSION = "3"

#Unix-style path to the MORSE default scene, within the prefix
DEFAULT_SCENE_PATH = "share/data/morse/morse_default.blend"

#MORSE prefix (automatically detected)
morse_prefix = ""
#Path to Blender executable (automatically detected)
blender_exec = ""
#Path to MORSE default scene (automatically detected)
default_scene_abspath = ""

class MorseError(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        return repr(self.value)

def retrieve_blender_from_path():
    try:
        blenders_in_path = subprocess.Popen(
                                ['which', '-a', 'blender'], 
                                stdout=subprocess.PIPE).communicate()[0]
        res = str(blenders_in_path).split('\n')[:-1]
    except OSError:
        return []
    
    return res
    
def check_blender_version(blender_path):
    try:
        version_str = subprocess.Popen(
                                [blender_path, '--version'], 
                                stdout=subprocess.PIPE).communicate()[0]
        # Convert the bytes into a string
        if sys.version_info>(3,0,0):
            version_str = str(version_str)
        version = version_str.split()[1] + '.' + version_str.split()[3][:-1]
    except OSError:
        return None
    
    logger.info("Checking version of " + blender_path + "... Found v." + version)
    
    if  version.split('.') >= MIN_BLENDER_VERSION.split('.') and \
        version.split('.') < STRICT_MAX_BLENDER_VERSION.split('.') :
        return version
    else:
        return False

def check_blender_python_version(blender_path):
    """ Creates a small Python script to execute within Blender and get the 
    current Python version bundled with Blender
    
    TODO: this method doesn't works because I couldn't find a way to exit 
    Blender in Python...
    For now, we don't check Python version in Blender.
    >>> blender -b or --background
    """
    
    with open("python_checker.py", "w") as f:
        f.write("import sys\n")
        f.write("print('.'.join((str(x) for x in sys.version_info[:2])))\n")
    
    try:
        version_str = subprocess.Popen(
                  [blender_path, '-b', '-P', 'python_checker.py'], 
                  stdout=subprocess.PIPE).communicate()[0].split()[0]
        version = version_str.decode()
    except OSError:
        os.remove("python_checker.py")
        return None
    
    logger.info("Checking version of Python within Blender " + blender_path + \
                    "... Found v." + version)
    
    if  version.split('.') >= MIN_PYTHON_VERSION.split('.') and \
        version.split('.') < STRICT_MAX_PYTHON_VERSION.split('.') :
            os.remove("python_checker.py")
            return version
    else:
        os.remove("python_checker.py")
        return False
        
def check_default_scene(prefix):
    
    global default_scene_abspath
    #Check morse_default.blend is found
    default_scene_abspath = os.path.join(os.path.normpath(prefix), os.path.normpath(DEFAULT_SCENE_PATH))
    
    #logger.info("Looking for the MORSE default scene here: " + default_scene_abspath)
    
    if not os.path.exists(default_scene_abspath):
        raise MorseError(default_scene_abspath)
    else:
        return default_scene_abspath

def check_setup():
    """
    Checks that the environment is correctly setup to run MORSE.
    Raises exceptions when an error is detected.
    """
    
    global morse_prefix, blender_exec, default_scene_abspath
    
    ###########################################################################
    #Check platform
    if not 'linux' in sys.platform:
        logger.warning("MORSE has only been tested on Linux. It may work " + \
        "on other operating systems as well, but without any guarantee")
    else:
        logger.info("Running on Linux. Alright.")
    
    ###########################################################################
    #Check PYTHONPATH variable
    
    found = False
    for dir in sys.path:
        if os.path.exists(os.path.join(dir, "morse/blender/main.py")):
            logger.info("Found MORSE libraries in '" + dir + "/morse/blender'. Alright.")
            found = True
            break
            
    if not found:
        logger.error(  "We could not find the MORSE Python libraries in your " +\
                        "system. If MORSE was installed to some strange location, " + \
                        "you may want to add it to your PYTHONPATH." + \
                        " Check INSTALL for more details.")
        raise MorseError("PYTHONPATH not set up.")
    ###########################################################################
    #Detect MORSE prefix
    #-> Check for $MORSE_ROOT, then script current prefix
    try:
        prefix = os.environ['MORSE_ROOT']
        logger.info("$MORSE_ROOT environment variable is set. Checking for default scene...")
        
        check_default_scene(prefix)
        logger.info("Default scene found. The prefix seems ok. Using it.")
        morse_prefix = prefix
        
    except MorseError:
        logger.warning("Couldn't find the default scene from $MORSE_ROOT prefix!\n" + \
        "Did you move your installation? You should fix that!\n" + \
        "Trying to look for alternative places...")
    except KeyError:
        pass
    
    if morse_prefix == "":
        #Trying to use the script location as prefix (removing the trailing '/bin'
        # if present)
        logger.info("Trying to figure out a prefix from the script location...")
        prefix = os.path.abspath(os.path.dirname(sys.argv[0]))
        if prefix.endswith('bin'):
            prefix = prefix[:-3]
        
        try:
            check_default_scene(prefix)
            
            logger.info("Default scene found. The prefix seems ok. Using it.")
            morse_prefix = prefix
            os.environ['MORSE_ROOT'] = prefix
            logger.info("Setting $MORSE_ROOT environment variable to default prefix [" + prefix + "]")
        
        except MorseError as me:
            logger.error("Could not find the MORSE default scene (I was expecting it " + \
                    "\nthere: " + me.value + ").\n" + \
                    "If you've installed MORSE files in an exotic location, check that \n" + \
                    "the $MORSE_ROOT environment variable points to MORSE root directory.\n" + \
                    "Else, try to reinstall MORSE.")
            raise
        
    
    
    ###########################################################################
    #Check Blender version
    #First, look for the $MORSE_BLENDER env variable
    try:
        blender_exec = os.environ['MORSE_BLENDER']
        version = check_blender_version(blender_exec)
        if version:
            logger.info("Blender found from $MORSE_BLENDER. Using it (Blender v." + \
            version + ")")
        elif version == False:
            blender_exec = ""
            logger.warning("The $MORSE_BLENDER environment variable points to an " + \
            "incorrect version of\nBlender! You should fix that! Trying to look " + \
            "for Blender in alternative places...")
        elif version == None:
            blender_exec = ""
            logger.warning("The $MORSE_BLENDER environment variable doesn't point " + \
            "to a Blender executable! You should fix that! Trying to look " + \
            "for Blender in alternative places...")
    except KeyError:
        pass

    if blender_exec == "":
        #Then, check the version of the Blender executable in the path
        for blender_path in retrieve_blender_from_path():
            blender_version_path = check_blender_version(blender_path)
            
            if blender_version_path:
                blender_exec = blender_path
                logger.info("Found Blender in your PATH\n(" + blender_path + \
                ", v." + blender_version_path + ").\nAlright, using it.")
                break
        
        #Eventually, look for another Blender in the MORSE prefix
        if blender_exec == "":
            blender_prefix = os.path.join(os.path.normpath(prefix), os.path.normpath("bin/blender"))
            blender_version_prefix = check_blender_version(blender_prefix)
            
            if blender_version_prefix:
                blender_exec = blender_prefix
                logger.info("Found Blender in your prefix/bin\n(" + blender_prefix + \
                ", v." + blender_version_prefix + ").\nAlright, using it.")
                
            else:
                logger.error("Could not find a correct Blender executable, neither in the " + \
                "path or in MORSE\nprefix. Blender >= " + MIN_BLENDER_VERSION + \
                " and < " + STRICT_MAX_BLENDER_VERSION + \
                " is required to run MORSE.\n" + \
                "You can alternatively set the $MORSE_BLENDER environment variable " + \
                "to point to\na specific Blender executable")
                raise MorseError("Could not find Blender executable")
    
    ###########################################################################
    #Check Python version within Blender
    #TODO: skipped for now. See check_blender_python_version() docstring for details
    '''
    python_version = check_blender_python_version(blender_exec)
    if not (python_version.split('.') >= MIN_PYTHON_VERSION.split('.') and 
            python_version.split('.') < STRICT_MAX_PYTHON_VERSION.split('.')):
        logger.error("Blender is using Python " + python_version + \
        ". Python  >= " + MIN_PYTHON_VERSION + " and < " + STRICT_MAX_PYTHON_VERSION + \
        " is required to run MORSE. Note the Blender usually provide it owns " + \
        "Python runtime that may differ from the system one.")
        raise MorseError("Bad Python version")
    else:
        logger.info("Blender is using Python " + python_version + \
        ". Alright.")
    '''

def create_copy_default_scene(filename = None):
    """
    Creates a copy of the default scene in the current path, ensuring an 
    unique name.
    """
    
    global default_scene_abspath
    
    if not filename:
        previous_scenes = glob.glob("scene.*.blend")
        num_list = [0]
        for scene in previous_scenes:
            try:
                num = re.findall('[0-9]+', scene)[0]
                num_list.append(int(num))
            except IndexError:
                pass
        num_list = sorted(num_list)
        new_num = num_list[-1]+1
        new_scene = os.path.join(os.curdir, 'scene.%02d.blend' % new_num)
    else:
        new_scene = os.path.normpath(filename)

    shutil.copy(default_scene_abspath, new_scene)
    
    return new_scene

def prelaunch():
    try:
        logger.setLevel(logging.WARNING)
        logger.info("Checking up your environment...\n")
        check_setup()
    except MorseError as e:
        logger.error("Your environment is not yet correctly setup to run MORSE!\n" +\
        "Please fix it with above informations.\n" +\
        "You can also run 'morse check' for more details.")
        sys.exit()

def launch_simulator(scene=None, script=None, player=False):
    """Starts Blender on an empty new scene or with a given scene."""
    
    global morse_prefix, blender_exec, default_scene_abspath
    
    logger.info("*** Launching MORSE ***\n")
    logger.info("PREFIX= " + morse_prefix)
    
    if not scene:
        scene = create_copy_default_scene()
        logger.info("Creating new scene " + scene)
        
    elif not os.path.exists(scene):
        logger.error(scene + " does not exist!\nIf you want to create a new scene " + \
        "called " + scene + ",\nplease use 'morse create " + scene + "'.")
        sys.exit(1)
        
    logger.info("Executing: " + blender_exec + " " + scene + "\n\n")
    
    if player:
        blender_exec += "player"
        logger.error("player mode not supported yet")
        sys.exit(1)

    #Flush all outputs before launching Blender process
    sys.stdout.flush()
   
    # Redefine the PYTHONPATH to include both the user-set path plus the 
    # default system paths (like '/usr/lib/python*')
    env = os.environ
    env["PYTHONPATH"] = ":".join(sys.path)

    #Replace the current process by Blender
    if script:
        logger.info("Executing MORSE script: " + script)
        os.execle(blender_exec, blender_exec, scene, "-P", script, env)
    else:
        os.execle(blender_exec, blender_exec, scene, env)

##
# TODO optparse is deprecated in Python 3.2 
# (but argparse was not included in the 3.1)
# http://docs.python.org/py3k/library/argparse.html
# http://docs.python.org/py3k/library/optparse.html
##
def cmd_check(*args, **kwargs):
    try:
        logger.info("Checking up your environment...\n")
        check_setup()
        sys.exit()
    except MorseError as e:
        logger.error("\nYour environment is not correctly setup to run MORSE!")
        sys.exit()
        logger.info("Your environment is correctly setup to run MORSE.")

def main():
    """
    # TODO work in progress...
    parser = argparse.ArgumentParser(usage="%prog [options] [scene.blend] [script.py]", 
        version="%prog " + VERSION, 
        description="MORSE" + VERSION + ", the OpenRobot Simulator - http://morse.openrobots.org ", 
        epilog="Copyright LAAS-CNRS 2011")
    parser.add_argument("-s", "--scene", dest="scene", metavar="FILE.blend", 
                      help="open the scene in the simulator editor")
    parser.add_argument("-c", "--create", dest="newscene", metavar="FILE.blend", 
                      help="creates a new empty scene and launchs the simulator interface")
    parser.add_argument("-r", "--run", action="store_true", dest="player", default=False,
                      help="runs a simulation (!) NOT YET IMPLEMENTED")
    parser.add_argument("-e", "--exec", dest="script", metavar="FILE.py", 
                      help="executes the given Python script within the scene")
    parser.add_argument("-C", "--check", action="callback", callback=cmd_check, 
                      help="checks the environment is correctly setup to run morse")

    (options, args) = parser.parse_args()
    # EOWIP
    """
    parser = optparse.OptionParser(usage="%prog [options] [scene.blend] [script.py]", 
        version="%prog " + VERSION, 
        description="MORSE" + VERSION + ", the OpenRobot Simulator - http://morse.openrobots.org ", 
        epilog="Copyright LAAS-CNRS 2011")
    parser.add_option("-s", "--scene", dest="scene", metavar="FILE.blend", 
                      help="launchs the simulator with the given scene")
    parser.add_option("-c", "--create", dest="newscene", metavar="FILE.blend", 
                      help="creates a new empty scene and launchs the simulator interface")
    parser.add_option("-r", "--run", action="store_true", dest="player", default=False,
                      help="runs a simulation without loading the simulator interface")
    parser.add_option("-e", "--exec", dest="script", metavar="FILE.py", 
                      help="executes the given Python script within the scene")
    parser.add_option("-C", "--check", action="callback", callback=cmd_check, 
                      help="checks the environment is correctly setup to run morse")

    (options, args) = parser.parse_args()

    if options.newscene:
        options.scene = create_copy_default_scene(options.newscene)
    elif not options.scene:
        for arg in args:
            if arg.endswith(".blend"):
                options.scene = arg
                break

    if not options.script:
        for arg in args:
            if arg.endswith(".py"):
                options.script = arg
                break

    prelaunch()
    launch_simulator(scene=options.scene, script=options.script, player=options.player)


if __name__ == '__main__':
    main()

